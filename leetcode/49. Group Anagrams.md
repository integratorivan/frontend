---
leetcodelevel: Medium
id: "49"
link: https://leetcode.com/problems/group-anagrams
---
```javascript
var groupAnagrams = function (strs) {
  const hash = {};
  const result = [];

  for (const iterator of strs) {
    const sorted = iterator.split('').sort().join('');

    if (hash[sorted]) {
      hash[sorted].push(iterator);
    } else {
      hash[sorted] = [iterator];
    }
  }

  for (const sorted in hash) {
    result.push(hash[sorted]);
  }

  return result;
};
```

Алгоритм в функции ﻿groupAnagrams использует подход с использованием хеш-таблицы для группировки анаграмм.
Вот, как работает данное решение:
	1.	Создается пустой объект ﻿hash, который будет использоваться в качестве хеш-таблицы для группировки анаграмм.
	2.	Создается пустой массив ﻿result, в который будут добавляться группы анаграмм.
	3.	Для каждой строки ﻿iterator из входного массива ﻿strs выполняются следующие действия:
	▪	Строка ﻿iterator разбивается на массив символов ﻿split('').
	▪	Полученный массив символов сортируется в алфавитном порядке ﻿sort().
	▪	Отсортированный массив символов объединяется обратно в строку ﻿join('').
	▪	Полученная отсортированная строка ﻿sorted служит в качестве ключа хеш-таблицы для группировки анаграмм.
	▪	Если в ﻿hash уже существует запись с ключом ﻿sorted, то текущая строка ﻿iterator добавляется в соответствующую группу анаграмм в ﻿hash.
	▪	В противном случае, создается новая запись в ﻿hash с ключом ﻿sorted и значением, представляющим единичную группу анаграмм, состоящую только из текущей строки ﻿iterator.
	4.	После обработки всех строк в ﻿strs, происходит перебор ключей хеш-таблицы ﻿hash с помощью цикла ﻿for...in:
	▪	Для каждого ключа ﻿sorted в ﻿hash, соответствующая группа анаграмм из ﻿hash добавляется в массив ﻿result.
	5.	Массив ﻿result, содержащий группы анаграмм, возвращается в качестве результата функции.
Таким образом, алгоритм создает хеш-таблицу ﻿hash, в которой ключами являются отсортированные строки (анаграммы), а значениями - массивы строк, представляющие группы анаграмм. В результате выполнения алгоритма, возвращается массив ﻿result, содержащий сгруппированные анаграммы.

Проход по каждой строке ﻿iterator из входного массива ﻿strs выполняется за время O(n), где n - количество строк в ﻿strs.
	•	Внутри этого прохода происходит разделение строки на символы с помощью ﻿split(''), сортировка символов с помощью ﻿.sort(), и объединение отсортированных символов обратно в строку с помощью ﻿join(''). Все эти операции выполняются за время O(m * log m), где m - максимальная длина строки.
	•	Добавление строк в хеш-таблицу ﻿hash и массив ﻿result происходит в худшем случае за время O(1).
	•	После прохода по всем строкам и формирования хеш-таблицы ﻿hash, следующий цикл ﻿for...in также выполняется за время O(k), где k - количество уникальных ключей в ﻿hash.
	•	В итоге, суммарная временная сложность алгоритма можно оценить как O(n * m * log m + k).
Кроме того, используется дополнительная память для хранения хеш-таблицы ﻿hash и массива ﻿result, которая зависит от количества уникальных ключей в ﻿hash и общего размера групп анаграмм.
Если максимальная длина строк является константой (m - постоянное значение), а количество уникальных ключей в ﻿hash и количество групп анаграмм также являются константами, то временную сложность можно упростить до O(n).